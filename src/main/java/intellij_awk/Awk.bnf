/*
    Grammar based on https://pubs.opengroup.org/onlinepubs/7908799/xcu/awk.html#tag_000_000_108_016
*/
{
  parserClass="intellij_awk.AwkParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Awk"
  psiImplClassSuffix="Impl"
  psiPackage="intellij_awk.psi"
  psiImplPackage="intellij_awk.psi.impl"

  elementTypeHolderClass="intellij_awk.psi.AwkTypes"
  elementTypeClass="intellij_awk.psi.AwkElementType"
  tokenTypeClass="intellij_awk.psi.AwkTokenType"

// %token VAR_NAME NUMBER STRING ERE
// %token FUNC_NAME   /* name followed by '(' without white space */
//
// /* Keywords  */
// %token       Begin   End
// /*          'BEGIN' 'END'                            */
//
// %token       Break   Continue   Delete   Do   Else
// /*          'break' 'continue' 'delete' 'do' 'else'  */
//
// %token       Exit   For   Function   If   In
// /*          'exit' 'for' 'function' 'if' 'in'        */
//
// %token       Next   Print   Printf   Return   While
// /*          'next' 'print' 'printf' 'return' 'while' */
//
// /* Reserved function names */
// %token BUILTIN_FUNC_NAME
//             /* one token for the following:
//              * atan2 cos sin exp log sqrt int rand srand
//              * gsub index length match split sprintf sub
//              * substr tolower toupper close system
//              */
// %token GETLINE
//             /* Syntactically different from other built-ins */
//
// /* Two-character tokens */
// %token ADD_ASSIGN SUB_ASSIGN MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN POW_ASSIGN
// /*     '+='       '-='       '*='       '/='       '%='       '^=' */
//
// %token  OR   AND  NO_MATCH   EQ   LE   GE   NE   INCR  DECR  APPEND
// /*      '||' '&&' '!~' '==' '<=' '>=' '!=' '++'  '--'  '>>'   */
//
// /* One-character tokens */
// %token '{' '}' '(' ')' '[' ']' ',' ';' NEWLINE
// %token '+' '-' '*' '%' '^' '!' '>' '<' '|' '?' ':' '~' '$' '='

  tokens = [
    comment='regexp:#.*'
    BEGIN='BEGIN'
    END='END'
    BREAK='break'
    CONTINUE='continue'
    DELETE='delete'
    DO='do'
    ELSE='else'
    EXIT='exit'
    FOR='for'
    FUNCTION='function'
    IF='if'
    IN='in'
    NEXT='next'
    PRINT='print'
    PRINTF='printf'
    RETURN='return'
    WHILE='while'
    BUILTIN_FUNC_NAME='regexp:atan2|cos|sin|exp|log|sqrt|int|rand|srand|gsub|index|length|match|split|sprintf|sub|substr|tolower|toupper|close|system'
    NUMBER='regexp:[0-9]+(?:\.[0-9]+)?(?:[eE][+-][0-9]+)?'
    STRING='regexp:(["]([^"\\]|\\.)*["])'
    ERE='regexp:/([^\\\n/]|\\[^\n])*/'
    GETLINE='getline'
    ADD_ASSIGN='+='
    SUB_ASSIGN='-='
    MUL_ASSIGN='*='
    DIV_ASSIGN='/='
    MOD_ASSIGN='%='
    POW_ASSIGN='^='
    OR='||'
    AND='&&'
    NO_MATCH='!~'
    EQ='=='
    LE='<='
    GE='>='
    NE='!='
    INCR='++'
    DECR='--'
    APPEND='>>'
    NEWLINE='regexp:\r\n|\n'
    DOLLAR='$' // for some reason $ doesn't work inline

    LBRACKET='['
    RBRACKET=']'
    LBRACE='{'
    RBRACE='}'
    LPAREN='('
    RPAREN=')'

    COMMA=','
    SEMICOLON=';'

    LT='<'
    GT='>'
    ADD='+'
    SUB='-'
    MUL='*'
    DIV='/'
    MOD='%'
    POW='^'
    MATCH='~'
    PIPE='|'
    NOT='!'
    QUESTION='?'
    COLON=':'
    ASSIGN='='
    
    /*
    The token VAR_NAME      consists of a word that is not a keyword or a name of a built-in function and is not followed immediately (without any delimiters) by the "(" character.
    The token FUNC_NAME consists of a word that is not a keyword or a name of a built-in function, followed immediately (without any delimiters) by the "(" character. The "(" character will not be included as part of the token.
    */
    FUNC_NAME='regexp:[a-zA-Z_]+[a-zA-Z_\d]*(?=\()'

    // via https://pubs.opengroup.org/onlinepubs/9699919799/utilities/awk.html
    SPECIAL_VAR_NAME='regexp:ARGC|ARGV|CONVFMT|ENVIRON|FILENAME|FNR|FS|NF|NR|OFMT|OFS|ORS|RLENGTH|RS|RSTART|SUBSEP'
    VAR_NAME='regexp:[a-zA-Z_]+[a-zA-Z_\d]*'
    // this is a special grammar for "preview only" because grammar-kit seems to not
    // support whitespaces
    livePreviewWs='regexp:[ \t]*(\\\n)*'
  ]
}

// /pattern/
// /pattern/ { ... }
// function f() { ... }
// TODO this won't parse 'BEGIN {} ;;;'
program ::= newline_opt item* (terminator item)* newline_opt

// BEGIN { ... }
// { ... }
// 1
// function a() { ... }
item             ::= FUNCTION (FUNC_NAME | VAR_NAME) LPAREN param_list_opt RPAREN
                       newline_opt action
                 | pattern action*
                 | action {
    mixin="intellij_awk.psi.impl.AwkItemMixin"
    implements="intellij_awk.psi.AwkNamedElement"
}

param_list_opt   ::= param_list?

param_list       ::= var_name (COMMA newline_opt var_name)*

pattern          ::= BEGIN
                 | END
                 | expr (COMMA newline_opt expr)?

action           ::= LBRACE newline_opt                           RBRACE
                 | LBRACE newline_opt terminated_statement_list   RBRACE
                 | LBRACE newline_opt unterminated_statement_list RBRACE

terminator       ::= (NEWLINE|SEMICOLON)+

terminated_statement_list ::= terminated_statement+

unterminated_statement_list ::= terminated_statement_list unterminated_statement
                 | unterminated_statement

terminated_statement ::= action newline_opt
                 | IF LPAREN expr RPAREN newline_opt terminated_statement
                       ELSE newline_opt terminated_statement
                 | IF LPAREN expr RPAREN newline_opt terminated_statement
                 | WHILE LPAREN expr RPAREN newline_opt terminated_statement
                 | FOR LPAREN simple_statement_opt SEMICOLON expr_opt SEMICOLON simple_statement_opt RPAREN newline_opt
                      terminated_statement
                 | FOR LPAREN var_name IN var_name RPAREN newline_opt
                      terminated_statement
                 | SEMICOLON newline_opt
                 | terminatable_statement NEWLINE newline_opt
                 | terminatable_statement SEMICOLON     newline_opt

unterminated_statement ::= terminatable_statement
                 | IF LPAREN expr RPAREN newline_opt terminated_statement
                      ELSE newline_opt unterminated_statement
                 | IF LPAREN expr RPAREN newline_opt unterminated_statement
                 | WHILE LPAREN expr RPAREN newline_opt unterminated_statement
                 | FOR LPAREN simple_statement_opt SEMICOLON expr_opt SEMICOLON simple_statement_opt RPAREN newline_opt
                      unterminated_statement
                 | FOR LPAREN var_name IN var_name RPAREN newline_opt
                      unterminated_statement

terminatable_statement ::= simple_statement
                 | BREAK
                 | CONTINUE
                 | NEXT
                 | EXIT expr_opt
                 | RETURN expr_opt
                 | DO newline_opt terminated_statement WHILE LPAREN expr RPAREN

simple_statement_opt ::= simple_statement?

simple_statement ::= DELETE var_name LBRACKET expr_list RBRACKET
                 | expr
                 | print_statement

print_statement  ::= simple_print_statement output_redirection?

simple_print_statement ::= PRINT  print_expr_list_opt
                 | PRINT  LPAREN multiple_expr_list RPAREN
                 | PRINTF print_expr_list
                 | PRINTF LPAREN multiple_expr_list RPAREN

output_redirection ::= GT  expr
                 | APPEND  expr
                 | PIPE    expr

expr_list_opt    ::= expr_list?

expr_list        ::= multiple_expr_list
                 | expr // TODO do we need this line?

multiple_expr_list ::= expr (COMMA newline_opt expr)*

expr_opt         ::= expr?

expr             ::= unary_expr
                 | non_unary_expr

/*
    Eliminate left recursion: https://web.cs.wpi.edu/~kal/PLT/PLT4.1.2.html

    A --> A α | β
    introduce a new nonterminal A' and rewrite the rule as

    A --> β A'
    A' --> ε | α A'   <-->  A' --> (α A')?
*/
unary_expr       ::= (ADD|SUB)  expr unary_expr1

unary_expr1      ::= (
                        (    POW      expr
                           | MUL      expr
                           | DIV      expr
                           | MOD      expr
                           | ADD      expr
                           | SUB      expr
                           |          non_unary_expr
                           | LT       expr
                           | LE       expr
                           | NE       expr
                           | EQ       expr
                           | GT       expr
                           | GE       expr
                           | MATCH    expr
                           | NO_MATCH expr
                           | IN var_name
                           | AND newline_opt expr
                           | OR  newline_opt expr
                           | QUESTION expr COLON expr
                           | PIPE simple_get
                       )
                       unary_expr1
                   )?

non_unary_expr   ::= (
                           LPAREN expr RPAREN
                         | LPAREN multiple_expr_list RPAREN IN var_name
                         | NOT expr
                         | simple_get (LT expr)?
                         | NUMBER
                         | STRING
                         | ERE
                         | lvalue INCR
                         | lvalue DECR
                         | INCR lvalue
                         | DECR lvalue
                         | lvalue POW_ASSIGN expr
                         | lvalue MOD_ASSIGN expr
                         | lvalue MUL_ASSIGN expr
                         | lvalue DIV_ASSIGN expr
                         | lvalue ADD_ASSIGN expr
                         | lvalue SUB_ASSIGN expr
                         | lvalue ASSIGN expr
                         | lvalue
                         | FUNC_NAME LPAREN expr_list_opt RPAREN
                              /* no white space allowed before LPAREN */ // TODO is this still relevant?
                         | BUILTIN_FUNC_NAME LPAREN expr_list_opt RPAREN
                         | BUILTIN_FUNC_NAME
                     )
                     non_unary_expr1

non_unary_expr1     ::= (
                          (     POW      expr
                              | MUL      expr
                              | DIV      expr
                              | MOD      expr
                              | ADD      expr
                              | SUB      expr
                              |          non_unary_expr
                              | LT       expr
                              | LE       expr
                              | NE       expr
                              | EQ       expr
                              | GT       expr
                              | GE       expr
                              | MATCH    expr
                              | NO_MATCH expr
                              | IN var_name
                              | AND newline_opt expr
                              | OR  newline_opt expr
                              | QUESTION expr COLON expr
                              | PIPE simple_get
                          )
                          non_unary_expr1
                      )?

print_expr_list_opt ::= print_expr_list?

print_expr_list  ::= print_expr (COMMA newline_opt print_expr)*

print_expr       ::= unary_print_expr
                 | non_unary_print_expr

unary_print_expr ::= (ADD|SUB) print_expr unary_print_expr1

unary_print_expr1  ::= (
                            (
                                  POW      print_expr
                                | MUL      print_expr
                                | DIV      print_expr
                                | MOD      print_expr
                                | ADD      print_expr
                                | SUB      print_expr
                                |          non_unary_print_expr
                                | MATCH    print_expr
                                | NO_MATCH print_expr
                                | IN var_name
                                | AND newline_opt print_expr
                                | OR  newline_opt print_expr
                                | QUESTION print_expr COLON print_expr
                            )
                            unary_print_expr1
                        )?

non_unary_print_expr ::= (
                       LPAREN expr RPAREN
                     | NOT print_expr
                     | LPAREN multiple_expr_list RPAREN IN var_name
                     | NUMBER
                     | STRING
                     | ERE
                     | lvalue INCR
                     | lvalue DECR
                     | INCR lvalue
                     | DECR lvalue
                     | lvalue POW_ASSIGN print_expr
                     | lvalue MOD_ASSIGN print_expr
                     | lvalue MUL_ASSIGN print_expr
                     | lvalue DIV_ASSIGN print_expr
                     | lvalue ADD_ASSIGN print_expr
                     | lvalue SUB_ASSIGN print_expr
                     | lvalue ASSIGN     print_expr
                     | lvalue
                     | FUNC_NAME LPAREN expr_list_opt RPAREN
                         /* no white space allowed before LPAREN */
                     | BUILTIN_FUNC_NAME LPAREN expr_list_opt RPAREN
                     | BUILTIN_FUNC_NAME
                 )
                 non_unary_print_expr1

non_unary_print_expr1 ::= (
                            (
                                POW      print_expr
                                | MUL      print_expr
                                | DIV      print_expr
                                | MOD      print_expr
                                | ADD      print_expr
                                | SUB      print_expr
                                |          non_unary_print_expr
                                | MATCH    print_expr
                                | NO_MATCH print_expr
                                | IN var_name
                                | AND newline_opt print_expr
                                | OR  newline_opt print_expr
                                | QUESTION print_expr COLON print_expr
                            )
                            non_unary_print_expr1
                          )?

lvalue           ::= var_name (LBRACKET expr_list RBRACKET)*
                 | DOLLAR expr

private var_name ::= SPECIAL_VAR_NAME
                 | VAR_NAME

simple_get       ::= GETLINE lvalue?

newline_opt      ::= NEWLINE*
