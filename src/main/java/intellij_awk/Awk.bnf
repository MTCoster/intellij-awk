{
  parserClass="intellij_awk.AwkParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Awk"
  psiImplClassSuffix="Impl"
  psiPackage="intellij_awk.psi"
  psiImplPackage="intellij_awk.psi.impl"

  elementTypeHolderClass="intellij_awk.psi.AwkTypes"
  elementTypeClass="intellij_awk.psi.AwkElementType"
  tokenTypeClass="intellij_awk.psi.AwkTokenType"

  psiImplUtilClass="intellij_awk.psi.impl.AwkPsiImplUtil"

// %token NAME NUMBER STRING ERE
// %token FUNC_NAME   /* name followed by '(' without white space */
//
// /* Keywords  */
// %token       Begin   End
// /*          'BEGIN' 'END'                            */
//
// %token       Break   Continue   Delete   Do   Else
// /*          'break' 'continue' 'delete' 'do' 'else'  */
//
// %token       Exit   For   Function   If   In
// /*          'exit' 'for' 'function' 'if' 'in'        */
//
// %token       Next   Print   Printf   Return   While
// /*          'next' 'print' 'printf' 'return' 'while' */
//
// /* Reserved function names */
// %token BUILTIN_FUNC_NAME
//             /* one token for the following:
//              * atan2 cos sin exp log sqrt int rand srand
//              * gsub index length match split sprintf sub
//              * substr tolower toupper close system
//              */
// %token GETLINE
//             /* Syntactically different from other built-ins */
//
// /* Two-character tokens */
// %token ADD_ASSIGN SUB_ASSIGN MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN POW_ASSIGN
// /*     '+='       '-='       '*='       '/='       '%='       '^=' */
//
// %token  OR   AND  NO_MATCH   EQ   LE   GE   NE   INCR  DECR  APPEND
// /*      '||' '&&' '!' '==' '<=' '>=' '!=' '++'  '--'  '>>'   */
//
// /* One-character tokens */
// %token '{' '}' '(' ')' '[' ']' ',' ';' NEWLINE
// %token '+' '-' '*' '%' '^' '!' '>' '<' '|' '?' ':' '~' '$' '='

  tokens = [
    comment='regexp:#.*'
    BEGIN='BEGIN'
    END='END'
    BREAK='break'
    CONTINUE='continue'
    DELETE='delete'
    DO='do'
    ELSE='else'
    EXIT='exit'
    FOR='for'
    FUNCTION='function'
    IF='if'
    IN='in'
    NEXT='next'
    PRINT='print'
    PRINTF='printf'
    RETURN='return'
    WHILE='while'
    BUILTIN_FUNC_NAME='regexp:atan2|cos|sin|exp|log|sqrt|int|rand|srand|gsub|index|length|match|split|sprintf|sub|substr|tolower|toupper|close|system'
    NUMBER='regexp:[0-9]+(?:\.[0-9]+)?(?:[eE][+-][0-9]+)?'
    STRING='regexp:(["]([^"\\]|\\.)*["])'
    GETLINE='getline'
    ADD_ASSIGN='+='
    SUB_ASSIGN='-='
    MUL_ASSIGN='*='
    DIV_ASSIGN='/='
    MOD_ASSIGN='%='
    POW_ASSIGN='^='
    OR='||'
    AND='&&'
    NO_MATCH='!'
    EQ='=='
    LE='<='
    GE='>='
    NE='!='
    INCR='++'
    DECR='--'
    APPEND='>>'
    NEWLINE='regexp:\r\n|\n'
    DOLLAR='$' // for some reason $ doesn't work inline

    /*
    The token NAME consists of a word that is not a keyword or a name of a built-in function and is not followed immediately (without any delimiters) by the "(" character.
    The token FUNC_NAME consists of a word that is not a keyword or a name of a built-in function, followed immediately (without any delimiters) by the "(" character. The "(" character will not be included as part of the token.
    */
    FUNC_NAME='regexp:[a-zA-Z_]+[a-zA-Z_\d]*(?=\()'
    NAME='regexp:[a-zA-Z_]+[a-zA-Z_\d]*'
    // this is a special grammar for "preview only" because grammar-kit seems to not
    // support whitespaces
    livePreviewWs='regexp:[ \t]*'
  ]
}

/*
    Grammar based on https://pubs.opengroup.org/onlinepubs/7908799/xcu/awk.html#tag_000_000_108_016
    TODO 1. Comments in grammar?
*/

// /pattern/
// /pattern/ { ... }
// function f() { ... }
// TODO this won't parse 'BEGIN {} ;;;'
program ::= item (terminator item)*

//program          ::= item_list
//                 | actionless_item_list
//                 ;

//item_list        ::= actionless_item_list item terminator
//                 | item_list            item terminator
//                 | item_list          action terminator
//                 | newline_opt
//                 ;
//
//actionless_item_list ::= item_list            pattern terminator
//                 | actionless_item_list pattern terminator
//                 ;

// BEGIN { ... }
// { ... }
// 1
// function a() { ... }
item             ::= FUNCTION FUNC_NAME '(' param_list_opt ')'
                       newline_opt action
// TODO: do we need 2 lines below?
//                 | FUNCTION NAME      '(' param_list_opt ')'
//                                         newline_opt action
                 | pattern action*
                 | action

param_list_opt   ::= param_list?

param_list       ::= NAME (',' newline_opt NAME)*

pattern          ::= BEGIN
                 | END
                 | expr (',' newline_opt expr)?

action           ::= '{' newline_opt                           '}'
                 | '{' newline_opt terminated_statement_list   '}'
                 | '{' newline_opt unterminated_statement_list '}'

terminator       ::= (NEWLINE|';')+
//terminator       ::= terminator ';'
//                 | terminator NEWLINE
//                 |            ';'
//                 |            NEWLINE
//                 ;

terminated_statement_list ::= terminated_statement+
//terminated_statement_list ::= terminated_statement
//                 | terminated_statement_list terminated_statement
//                 ;

unterminated_statement_list ::= terminated_statement_list unterminated_statement
                 | unterminated_statement

terminated_statement ::= action newline_opt
                 | IF '(' expr ')' newline_opt terminated_statement
                       ELSE newline_opt terminated_statement
                 | IF '(' expr ')' newline_opt terminated_statement
                 | WHILE '(' expr ')' newline_opt terminated_statement
                 | FOR '(' simple_statement_opt ';' expr_opt ';' simple_statement_opt ')' newline_opt
                      terminated_statement
                 | FOR '(' NAME IN NAME ')' newline_opt
                      terminated_statement
                 | ';' newline_opt
                 | terminatable_statement NEWLINE newline_opt
                 | terminatable_statement ';'     newline_opt

unterminated_statement ::= terminatable_statement
                 | IF '(' expr ')' newline_opt terminated_statement
                      ELSE newline_opt unterminated_statement
                 | IF '(' expr ')' newline_opt unterminated_statement
                 | WHILE '(' expr ')' newline_opt unterminated_statement
                 | FOR '(' simple_statement_opt ';' expr_opt ';' simple_statement_opt ')' newline_opt
                      unterminated_statement
                 | FOR '(' NAME IN NAME ')' newline_opt
                      unterminated_statement

terminatable_statement ::= simple_statement
                 | BREAK
                 | CONTINUE
                 | NEXT
                 | EXIT expr_opt
                 | RETURN expr_opt
                 | DO newline_opt terminated_statement WHILE '(' expr ')'

simple_statement_opt ::= simple_statement?

simple_statement ::= DELETE NAME '[' expr_list ']'
                 | expr
                 | print_statement

print_statement  ::= simple_print_statement output_redirection?
//print_statement  ::= simple_print_statement
//                 | simple_print_statement output_redirection
//                 ;

simple_print_statement ::= PRINT  print_expr_list_opt
                 | PRINT  '(' multiple_expr_list ')'
                 | PRINTF print_expr_list
                 | PRINTF '(' multiple_expr_list ')'

output_redirection ::= '>'    expr
                 | APPEND expr
                 | '|'    expr

expr_list_opt    ::= expr_list?

expr_list        ::= multiple_expr_list
                 | expr // TODO do we need this line?

multiple_expr_list ::= expr (',' newline_opt expr)*

expr_opt         ::= expr?

expr             ::= unary_expr
                 | non_unary_expr

/*
    Eliminate left recursion: https://web.cs.wpi.edu/~kal/PLT/PLT4.1.2.html

    A --> A α | β
    introduce a new nonterminal A' and rewrite the rule as

    A --> β A'
    A' --> ε | α A'   <-->  A' --> (α A')?
*/
unary_expr       ::= ('+'|'-')  expr unary_expr1

unary_expr1      ::= (
                        (    '^'      expr
                           | '*'      expr
                           | '/'      expr
                           | '%'      expr
                           | '+'      expr
                           | '-'      expr
                           |          non_unary_expr
                           | '<'      expr
                           | LE       expr
                           | NE       expr
                           | EQ       expr
                           | '>'      expr
                           | GE       expr
                           | '~'      expr
                           | NO_MATCH expr
                           | IN NAME
                           | AND newline_opt expr
                           | OR  newline_opt expr
                           | '?' expr ':' expr
                           | '|' simple_get
                       )
                       unary_expr1
                   )?

non_unary_expr   ::= (
                           '(' expr ')'
                         | '(' multiple_expr_list ')' IN NAME
                         | '!' expr
                         | simple_get ('<' expr)?
                         | NUMBER
                         | STRING
                         | ERE
                         | lvalue INCR
                         | lvalue DECR
                         | INCR lvalue
                         | DECR lvalue
                         | lvalue POW_ASSIGN expr
                         | lvalue MOD_ASSIGN expr
                         | lvalue MUL_ASSIGN expr
                         | lvalue DIV_ASSIGN expr
                         | lvalue ADD_ASSIGN expr
                         | lvalue SUB_ASSIGN expr
                         | lvalue '=' expr
                         | lvalue
                         | FUNC_NAME '(' expr_list_opt ')'
                              /* no white space allowed before '(' */ // TODO is this still relevant?
                         | BUILTIN_FUNC_NAME '(' expr_list_opt ')'
                         | BUILTIN_FUNC_NAME
                     )
                     non_unary_expr1

non_unary_expr1     ::= (
                          (     '^'      expr
                              | '*'      expr
                              | '/'      expr
                              | '%'      expr
                              | '+'      expr
                              | '-'      expr
                              |          non_unary_expr
                              | '<'      expr
                              | LE       expr
                              | NE       expr
                              | EQ       expr
                              | '>'      expr
                              | GE       expr
                              | '~'      expr
                              | NO_MATCH expr
                              | IN NAME
                              | AND newline_opt expr
                              | OR  newline_opt expr
                              | '?' expr ':' expr
                              | '|' simple_get
                          )
                          non_unary_expr1
                      )?

print_expr_list_opt ::= print_expr_list?

print_expr_list  ::= print_expr (',' newline_opt print_expr)*
//print_expr_list  ::= print_expr
//                 | print_expr_list ',' newline_opt print_expr
//                 ;

print_expr       ::= unary_print_expr
                 | non_unary_print_expr

unary_print_expr ::= ('+'|'-') print_expr unary_print_expr1

unary_print_expr1  ::= (
                            (
                                  '^'      print_expr
                                | '*'      print_expr
                                | '/'      print_expr
                                | '%'      print_expr
                                | '+'      print_expr
                                | '-'      print_expr
                                |          non_unary_print_expr
                                | '~'      print_expr
                                | NO_MATCH print_expr
                                | IN NAME
                                | AND newline_opt print_expr
                                | OR  newline_opt print_expr
                                | '?' print_expr ':' print_expr
                            )
                            unary_print_expr1
                        )?

non_unary_print_expr ::= (
                       '(' expr ')'
                     | '!' print_expr
                     | '(' multiple_expr_list ')' IN NAME
                     | NUMBER
                     | STRING
                     | ERE
                     | lvalue INCR
                     | lvalue DECR
                     | INCR lvalue
                     | DECR lvalue
                     | lvalue POW_ASSIGN print_expr
                     | lvalue MOD_ASSIGN print_expr
                     | lvalue MUL_ASSIGN print_expr
                     | lvalue DIV_ASSIGN print_expr
                     | lvalue ADD_ASSIGN print_expr
                     | lvalue SUB_ASSIGN print_expr
                     | lvalue '=' print_expr
                     | lvalue
                     | FUNC_NAME '(' expr_list_opt ')'
                         /* no white space allowed before '(' */
                     | BUILTIN_FUNC_NAME '(' expr_list_opt ')'
                     | BUILTIN_FUNC_NAME
                 )
                 non_unary_print_expr1

non_unary_print_expr1 ::= (
                            (
                                '^'      print_expr
                                | '*'      print_expr
                                | '/'      print_expr
                                | '%'      print_expr
                                | '+'      print_expr
                                | '-'      print_expr
                                |          non_unary_print_expr
                                | '~'      print_expr
                                | NO_MATCH print_expr
                                | IN NAME
                                | AND newline_opt print_expr
                                | OR  newline_opt print_expr
                                | '?' print_expr ':' print_expr
                            )
                            non_unary_print_expr1
                          )?

lvalue           ::= NAME ('[' expr_list ']')*
                 | DOLLAR expr

//non_unary_input_function ::= simple_get ('<' expr)?
//                 | non_unary_expr '|' simple_get
//                 ;

//unary_input_function ::= unary_expr '|' simple_get
//                 ;

simple_get       ::= GETLINE lvalue?

newline_opt      ::= NEWLINE*
//newline_opt      ::= /* empty */
//                 | newline_opt NEWLINE
//                 ;
